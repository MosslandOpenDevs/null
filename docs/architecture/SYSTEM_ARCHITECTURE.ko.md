# 시스템 아키텍처

## 개요

NULL은 순차적으로 작동하는 네 개의 핵심 엔진으로 운영됩니다: **제네시스 → 시뮬레이션 → 문서화 → 저장**. 실시간 프레젠테이션 레이어(옴니스코프)가 시뮬레이션 상태를 관찰자에게 스트리밍합니다.

## 핵심 엔진

### 1. 제네시스 노드
세계 구축 엔진. 시드 프롬프트를 받아 전체 시뮬레이션 환경을 생성합니다.

**책임:**
- 시드 프롬프트를 세계 매개변수(시대, 기술 수준, 사회 구조)로 파싱
- 배경, 신념, 동기를 가진 초기 에이전트 페르소나 생성
- 시작 조건 설정 (자원, 권력 역학, 정보 비대칭)
- 시뮬레이션 규칙과 제약 조건 정의

**입력:** 시드 프롬프트 (예: "사이버펑크 조선 왕조, 2145년")
**출력:** 세계 설정 + N개 에이전트 페르소나 + 초기 상태

### 2. 하이브 마인드 엔진
집단 지성 레이어. 에이전트들이 협력하여 문명을 기록하는 살아있는 위키를 유지합니다.

**책임:**
- 에이전트에 의한 실시간 위키 페이지 생성 및 편집
- 합의 기반 사실 확립 (정전 vs. 전설)
- 에이전트 상호작용으로부터 지식 그래프 구축
- 모순 감지 및 해결 프로토콜

**저장소:** PostgreSQL + pgvector를 사용한 위키 항목 전반의 시맨틱 검색.

### 3. 외부 현실 주입
실제 세계의 외부 데이터를 주입하여 시뮬레이션과 연결합니다.

**책임:**
- 검색 API(Tavily/Perplexity)를 통한 실시간 뉴스, 연구, 데이터 가져오기
- 외부 이벤트를 세계 내 이벤트로 변환
- 정보 과부하 방지를 위한 주입 빈도 제어 유지
- 외부 데이터가 에이전트 네트워크를 통해 전파되는 방식 추적

### 4. 시간 왜곡 엔진
시뮬레이션의 시간 흐름을 제어합니다.

**책임:**
- 시뮬레이션 시간 가속 또는 감속 (실제 1시간 = 시뮬레이션 N년)
- 시대 전환 트리거 (기술 혁명, 사회 변동)
- 세대 이벤트 스케줄링 (지도자 교체, 문화 운동)
- 시간 기반 에이전트 신념의 쇠퇴와 진화 관리

## 5. WebSocket 이벤트 스트리밍

시뮬레이션 백엔드와 옴니스코프 프론트엔드 간의 실시간 브릿지.

**이벤트 타입:**
- `agent.state` — 에이전트 상태 변경 (활성, 토론 중, 대기, 음모 중)
- `agent.message` — 에이전트 간 새 대화 메시지
- `relation.update` — 동맹 형성, 해체, 변경
- `epoch.transition` — 에포크 경계 통과, 새 시대 시작
- `event.triggered` — 랜덤 또는 주입된 이벤트 발화
- `wiki.edit` — 위키 페이지 생성 또는 수정
- `consensus.reached` — 정전/전설 상태 변경

**프로토콜:**
- WebSocket으로 양방향 통신 (신의 개입 명령이 상류로 전송)
- EventSource (SSE)로 읽기 전용 관찰자 폴백
- 메시지 형식: `{ type, timestamp, epoch, payload }` 엔벨로프의 JSON
- 클라이언트 측 Zustand 스토어가 이벤트를 소비하여 코스모그래프 상태 업데이트

## 6. 헤럴드 파이프라인

원시 시뮬레이션 이벤트를 인간이 읽을 수 있는 알림으로 변환하는 AI 기반 내러티브 요약 레이어.

**파이프라인:**
1. **이벤트 수집기**: 슬라이딩 윈도우(설정 가능, 기본 ~30초) 동안 중요 이벤트를 수집
2. **중요도 필터**: 내러티브 영향도로 이벤트 점수화 (파벌 변동, 배신, 합의 변경이 최고 순위)
3. **산문 생성기**: LLM 호출(경량 모델)로 점수화된 이벤트를 내러티브 산문으로 변환
4. **전달**: 옴니스코프 알림 시스템으로 헤럴드 카드 푸시 및 헤럴드 히스토리에 저장

**"Catch Me Up" 플로우:**
1. 클라이언트가 마지막 확인 타임스탬프 이후의 요약 요청
2. 백엔드가 해당 범위의 모든 헤럴드 항목 조회
3. LLM이 압축된 3~5문장 브리핑 생성
4. 확장된 표시 시간의 특별 헤럴드 카드로 전달

## 아키텍처 흐름

```
[시드 프롬프트]
    ↓
[제네시스 노드] → 세계 설정 + 에이전트 페르소나
    ↓
[시뮬레이션 루프]
    ├── 에이전트 대화 (토론, 협상, 음모)
    ├── 이벤트 시스템 (랜덤 이벤트, 외부 주입, 신의 개입)
    ├── 시간 왜곡 (시대 진행)
    └── 합의 엔진 (사실 확립)
    ↓
[하이브 마인드] → 위키 페이지, 지식 그래프
    ↓
[저장 레이어] → PostgreSQL + pgvector + Redis 캐시
    ↓
[이벤트 스트림] → WebSocket / SSE
    ↓
[옴니스코프] → KnowledgeHub (위키/그래프/스트라타/레조넌스) + SystemPulse + 타임라인 리본
    ↓
[내보내기] → JSON / CSV / Wiki / WebM / SVG / Markdown 내러티브 / 학습 데이터 (ChatML / Alpaca / ShareGPT)
    ↑
[시맨틱 세디먼트] → 엔티티 멘션, 택소노미 트리, 템포럴 스트라타, 시맨틱 이웃
```

## 7. 시맨틱 세디먼트 레이어 (Semantic Sediment)

에이전트가 생성한 콘텐츠에서 의미를 자동으로 발견하고 연결하는 AI 기반 데이터 조직 패러다임.

**핵심 개념:**
- **엔티티 멘션 (Entity Mentions)**: NER + 퍼지 매칭으로 자연어에서 에이전트, 위키 페이지, 파벌 참조를 감지. 양방향 링크를 자동 생성.
- **이머전트 택소노미 (Emergent Taxonomy)**: 임베딩 클러스터링을 통한 바텀업 카테고리 트리 자동 생성. 인간의 분류 없이 LLM이 계층적으로 레이블링.
- **템포럴 스트라타 (Temporal Strata)**: 에포크 경계에 대한 지질학적 시간 은유. 각 지층은 출현한 개념, 퇴조한 개념, 지배적 주제를 기록.

**백그라운드 서비스:**

| 서비스 | 주기 | 역할 |
|--------|------|------|
| `MentionExtractor` | 저장 시 | NER + 퍼지 매칭 엔티티 멘션 추출 |
| `SemanticIndexer` | 60초 | 임베딩 생성 + 시맨틱 이웃 발견 |
| `TaxonomyBuilder` | 300초 | 클러스터링 → 계층 트리 자동 생성 |
| `StratumDetector` | 에포크 종료 시 | 시간 지층 요약, 개념 출현/소멸 |
| `ConvergenceDetector` | 120초 | 월드 간 공명 감지 (기존) |

**신규 데이터베이스 테이블:**
- `entity_mentions` — 대화/위키에서 자동 추출된 엔티티 참조
- `semantic_neighbors` — 임베딩 기반 유사도 관계
- `taxonomy_nodes` — 계층 분류 트리 (자기참조)
- `taxonomy_memberships` — 엔티티-분류노드 매핑
- `strata` — 에포크별 시간 요약 (JSONB 개념 추적)
- `bookmarks` — 사용자 세션 기반 컬렉션

## 데이터 흐름

1. **시드 → 제네시스:** 인간이 주제/시나리오 시드를 제공
2. **제네시스 → 에이전트:** 엔진이 고유한 세계관을 가진 페르소나를 생성
3. **에이전트 → 대화:** 다중 에이전트 토론, 동맹, 갈등
4. **대화 → 하이브 마인드:** 결과의 구조화된 문서화
5. **하이브 마인드 → 저장소:** 벡터 임베딩이 포함된 영구 지식 기반
6. **저장소 → 시맨틱 세디먼트:** MentionExtractor, SemanticIndexer, TaxonomyBuilder가 새 콘텐츠 처리
7. **세디먼트 → 스트라타:** StratumDetector가 에포크 경계 요약
8. **저장소 → 이벤트 스트림:** 연결된 클라이언트로의 실시간 WebSocket 이벤트
9. **이벤트 스트림 → 옴니스코프:** 코스모그래프 시각화, 오라클 패널, 헤럴드 알림
10. **헤럴드 파이프라인:** 이벤트를 내러티브 산문으로 병렬 처리
